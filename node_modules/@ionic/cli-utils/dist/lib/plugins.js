"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const chalk = require("chalk");
const project_1 = require("./project");
const modules_1 = require("./modules");
const fs_1 = require("./utils/fs");
const http_1 = require("./http");
exports.KNOWN_PLUGINS = ['cordova', 'proxy', 'ionic1', 'ionic-angular'];
exports.ORG_PREFIX = '@ionic';
exports.PLUGIN_PREFIX = 'cli-plugin-';
exports.ERROR_PLUGIN_NOT_INSTALLED = 'PLUGIN_NOT_INSTALLED';
exports.ERROR_PLUGIN_NOT_FOUND = 'PLUGIN_NOT_FOUND';
exports.ERROR_PLUGIN_INVALID = 'PLUGIN_INVALID';
function formatFullPluginName(name) {
    return `${exports.ORG_PREFIX}/${exports.PLUGIN_PREFIX}${name}`;
}
exports.formatFullPluginName = formatFullPluginName;
function loadPlugins(env) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!env.project.directory) {
            return () => __awaiter(this, void 0, void 0, function* () { });
        }
        const mPath = path.join(env.project.directory, 'node_modules', '@ionic');
        const ionicModules = yield fs_1.readDir(mPath);
        const pluginPkgs = ionicModules
            .filter(pkgName => pkgName.indexOf(exports.PLUGIN_PREFIX) === 0)
            .map(pkgName => `${exports.ORG_PREFIX}/${pkgName}`);
        const plugins = yield Promise.all(pluginPkgs.map(pkgName => {
            return loadPlugin(env, pkgName, { askToInstall: false });
        }));
        const project = yield env.project.load();
        const projectPlugin = formatFullPluginName(project.type);
        if (!pluginPkgs.includes(projectPlugin)) {
            try {
                const plugin = yield loadPlugin(env, projectPlugin, {
                    askToInstall: true,
                    message: `Looks like this is an ${project_1.PROJECT_TYPES_PRETTY.get(project.type)} project, would you like to install ${chalk.green(projectPlugin)} and continue?`,
                });
                plugins.push(plugin);
            }
            catch (e) {
                if (e !== exports.ERROR_PLUGIN_NOT_INSTALLED) {
                    throw e;
                }
            }
        }
        const proxyPluginPkg = formatFullPluginName('proxy');
        const [, proxyVar] = http_1.getGlobalProxy();
        if (proxyVar && !pluginPkgs.includes(proxyPluginPkg)) {
            try {
                const plugin = yield loadPlugin(env, proxyPluginPkg, {
                    askToInstall: true,
                    message: `Detected '${chalk.green(proxyVar)}' in environment, but to proxy CLI requests, you'll need ${chalk.green(proxyPluginPkg)}. Would you like to install it and continue?`,
                });
                plugins.push(plugin);
            }
            catch (e) {
                if (e !== exports.ERROR_PLUGIN_NOT_INSTALLED) {
                    throw e;
                }
            }
        }
        for (let plugin of plugins) {
            const ns = plugin.namespace;
            if (ns) {
                env.namespace.namespaces.set(ns.name, () => ns);
            }
            if (plugin.registerHooks) {
                plugin.registerHooks(env.hooks);
            }
        }
    });
}
exports.loadPlugins = loadPlugins;
function loadPlugin(env, pluginName, { message, askToInstall = true }) {
    return __awaiter(this, void 0, void 0, function* () {
        let m;
        if (!message) {
            message = `The plugin ${chalk.green(pluginName)} is not installed. Would you like to install it and continue?`;
        }
        try {
            const mPath = path.join(env.project.directory, 'node_modules', ...pluginName.split('/'));
            m = require(mPath);
        }
        catch (e) {
            if (e.code !== 'MODULE_NOT_FOUND') {
                throw e;
            }
            let foundPackageNeeded = exports.KNOWN_PLUGINS.map(kp => formatFullPluginName(kp))
                .find(kp => e.message && e.message.includes(kp));
            if (!foundPackageNeeded) {
                throw `Dependency missing for ${chalk.bold(pluginName)}:\n\n  ${chalk.red('[ERROR]')}: ${e.message}`;
            }
        }
        if (!m && !askToInstall) {
            throw exports.ERROR_PLUGIN_NOT_INSTALLED;
        }
        if (!m) {
            const inquirer = modules_1.load('inquirer');
            const answers = yield inquirer.prompt([{
                    type: 'confirm',
                    name: 'installPlugin',
                    message,
                }]);
            if (answers['installPlugin']) {
                const pluginInstallVersion = `${pluginName}@${getReleaseChannelName(env)}`;
                yield env.shell.run('npm', ['install', '--save-dev', pluginInstallVersion], {});
                return loadPlugin(env, pluginName, { askToInstall });
            }
            else {
                throw exports.ERROR_PLUGIN_NOT_INSTALLED;
            }
        }
        return m;
    });
}
exports.loadPlugin = loadPlugin;
function getReleaseChannelName(env) {
    if (env.versions.cli.includes('alpha')) {
        return 'canary';
    }
    if (env.versions.cli.includes('beta')) {
        return 'beta';
    }
    return 'latest';
}
exports.getReleaseChannelName = getReleaseChannelName;
